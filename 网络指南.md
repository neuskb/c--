# 网络指南

## HTTP

### 常见错误码
* 1xx

1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

* 2xx

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮HEAD请求，服务器返回的响应头都会有 body 数据。

「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。

* 3xx

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的URL重新发送请求获取资源，也就是重定向。

「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。

「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
301 和 302 都会在响应头⾥使⽤字段Location，指明后续要跳转的URL，浏览器会⾃动重定向新的 URL。

「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。

* 4xx

4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。

「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。

「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。

「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

* 5xx

5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。

「500 Internal ServerError」与400类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。

「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。

「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。

「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。

### 常见字段
* Host：服务器域名
* Content-Length：回应的数据长度
* Connection：客户端要求服务器使用TCP持久连接
* Content-Type：⽤于服务器回应时，告诉客户端，本次数据是什么格式
* Accept：客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式
* Content-Encoding：说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式
* Accept-Encoding：客户端在请求时，说明⾃⼰可以接受哪些压缩⽅法

### GET与POST





## TCP

### 为什么需要TCP，TCP工作在哪一层
IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。

如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。
因为 TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的。

建议一个tcp连接，需要客户端与服务器端达成三个信息的共识
* socket：由IP地址和端口号组成
* 序列号：用来解决乱序问题
* 窗口大小：用来做流量控制

### 三次握手
* 第三次握手可以携带数据，前两次握手是不可以携带数据的。

* 查看tcp连接状态
```
netstat -anpt
```
* 为什么是三次握手？
    * 阻止重复历史连接的初始化
    * 同步双方的初始序列号
    * 避免资源浪费

不使⽤「两次握⼿」和「四次握⼿」的原因：

「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；
「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。

* MTU MSS
    * MTU：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节；
    * MSS：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度；

### 四次挥手
* 为什么需要四次挥手？
    * 关闭连接时，客户端向服务端发送FIN时，仅仅表示客户端不再发送数据了但是还能接收数据。
    * 服务器收到客户端的FIN报⽂时，先回⼀个ACK应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送FIN报⽂给客户端来表示同意现在关闭连接

### TIME_WAIT
* 为什么TIME_WAIT等待的时间是2MSL ？

主动关闭连接的，才有TIME_WAIT状态。
MSL是Maximum Segment Lifetime，报⽂最⼤⽣存时间。它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

* MSL与TTL的区别

MSL的单位是时间，⽽TTL是经过路由跳数。所以MSL应该要⼤于等于TTL 消耗为0的时间，以确保报⽂已被⾃然消亡。

* TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：

⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待2倍的时间。

在Linux系统⾥2MS 默认是60秒，那么⼀个MSL也就是30秒。Linux系统停留在TIME_WAIT的时间为固定的60秒。

* 为什么需要TIME_WAIT状态？
    * 防止旧连接的数据包
    * 保证连接正确关闭

### TCP重传机制
* 常见的重传机制
    * 超时重传
    * 快速重传
    * SACK
    * D-SACK

* 超时重传

发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK确认应答报文，就会重发该数据。

超时时间的设置：
用RTO（Retransmission Timeout）表示。超时重传时间RTO的值应该略大于报文往返RTT（Round-Trip Time 往返时延）的值。并且应该是个动态变化的值。

* 快速重传

不以时间为驱动，而是以数据驱动重传。工作方式是当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段。

快速重传只解决了一个问题，就是超时时间问题，但是它依然面临着另外一个问题，就是重传的时候，是重传之前的一个，还是重传所有。于是有了SACK方法。

* SACK（Selective Acknowledgment 选择性确认）

需要在TCP头部选项字段里加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，就可以只重传丢失的数据。

* D-SACK（Duplicate SACK）

使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接收了。

D-SACK好处：
1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了;
2. 可以知道是不是「发送⽅」的数据包被⽹络延迟了;
3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了;

* 滑动窗口

TCP每发送一个数据，都要进行一次确认应答，这样效率很慢。所以引入窗口的概念，可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

TCP头⾥有⼀个字段叫Window，也就是窗⼝⼤⼩。这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。

窗口大小由接收方决定。

### 拥塞控制
控制的⽬的就是避免「发送⽅」的数据填满整个⽹络。

* 拥塞窗口

cwnd，是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。拥塞窗⼝ cwnd 变化的规则：

1. 只要⽹络中没有出现拥塞， cwnd 就会增⼤；
2. 但⽹络中出现了拥塞， cwnd 就减少；

主要的四个算法：
* 慢启动

tcp在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动就是一点点的提高发送数据包的数量。

慢启动算法原则：当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1。那慢启动涨到什么时候是个头呢？有一个叫慢启动门限ssthresh （slow start threshold）状态变量。

1. 当 cwnd < ssthresh 时，使⽤慢启动算法。
2. 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。

* 拥塞避免算法

前⾯说道，当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。
⼀般来说 ssthresh 的⼤⼩是 65535 字节。

那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时， cwnd 增加 1/cwnd。

就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进⾏重传。

当触发了重传机制，也就进⼊了「拥塞发⽣算法」。


* 拥塞发生

当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：
1. 超时重传
2. 快速重传

这两种使⽤的拥塞发送算法是不同的，接下来分别来说说。
发⽣超时重传的拥塞发⽣算法：

当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。这个时候， ssthresh 和 cwnd 的值会发⽣变化：
1. ssthresh 设为 cwnd/2 ，
2. cwnd 重置为 1

发⽣快速重传的拥塞发⽣算法：

当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地重传，不必等待超时再重传。

则 ssthresh 和 cwnd 变化如下：
1. cwnd = cwnd/2 ，也就是设置为原来的⼀半;
2. ssthresh = cwnd ;
3. 进⼊快速恢复算法

* 快速恢复
    * 拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
    * 重传丢失的数据包；
    * 如果再收到重复的 ACK，那么 cwnd 增加 1；
    * 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从duplicatedACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊拥塞避免状态；


