# c++基础指南
[toc]

## c和c++有什么区别
* c++是面向对象的语言，c是面向过程的语言
* c++引入new/delete运算符，取代了c中的malloc/free库函数
* c++引入引用的概念，c中没有
* c++引入类的概念，c中没有
* c++引入了函数重载的特性，c中没有

## a和&a有什么区别
假如int a[5]= {1,2,3,4,5};
* a是数组首元素地址，+1表示地址值加上一个int类型的大小，*(a+1)=a[1]
* &a是数组的指针，其类型为int(*)[10],表示整个数组的指针，这个指针指向的内存大小是整个数组的总大小，所以 *(&a+1)就是数组a尾元素后一个元素的地址

## static关键字的作用
* 修饰局部变量时，使得该变量在静态存储区分配内存，生命周期和程序相同，但是作用域还是局部作用域
* 修饰全局变量时，使得该变量在静态存储区分配内存，在声明该变量的整个文件中都是可见的，而在文件外是不可见的
* 修饰函数时，在声明该函数的整个文件中都是可见的
* 修饰成员变量时，所有的对象都只维护一份拷贝，可以实现不同对象间的数据共享，不需要实例化对象即可访问，不能在类内部初始化，一般在类外部初始化，并且初始化不加static
* 修饰成员函数时，该函数不接收this指针，只能访问类的静态成员，不需要实例化对象即可访问

## #define和const区别
* 编译器处理方式不同：#define宏是在预处理阶段展开，不能对宏定义进行调试，而const常量是在编译阶段使用
* 类型和安全检查不同，#define宏没有类型，不做任何检查，仅仅是代码展开，而const常量有具体类型，在编译阶段会执行类型检查
* 存储方式不同：#define宏仅仅是代码展开，直接进行替换，不会分配内存，而const常量会分配内存
* 定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效

## 静态链接和动态链接区别
* 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处，优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接
* 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接，优点在于多个程序可以共享同一个动态库，节省资源，缺点在于由于运行时加载，可能影响程序的前期执行性能

## float和0值比较
```
const float EPSINON = 0.00001;
//其中EPSINON是允许的误差（即精度）
if ((x >= - EPSINON) && (x <= EPSINON) {
    
} 
```
因为计算机在处理浮点数的时候是有误差的。

## sizeof和strlen的区别
* sizeof是一个操作符，strlen是库函数
* sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字段串作参数
* 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来
* 数组做sizeof的参数不退化，传递给strlen就退化成指针

## volatile、mutable、explicit关键字用法
1. volatile：

易变关键字，告诉编译器不要对这个变量进行优化，每次都要去绝对地址取值，而不能从寄存器上取值，作用是用来进行多线程编程。

volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读
寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。

多线程下的volatile

有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中。

2. mutable

mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。

3. explicit

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：

* explicit 关键字只能用于类内部的构造函数声明上
* explicit 关键字作用于单个参数的构造函数
* 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换

## 全局变量和局部变量，操作系统是怎么知道的
操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

## 简述strcpy、sprintf 与memcpy 的区别
* 操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
* 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
* 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝。

## 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？
应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。

优点：
* 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
* 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

缺点：

* 代码膨胀，产生更多的开销；
* 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
* 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
* 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

## shared_ptr是如何实现的？
* 构造函数中计数初始化为1；
* 拷贝构造函数中计数值加1；
* 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
* 析构函数中引用计数减1；
* 在赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象。
代码如下：
```
template <class T>
class shared_ptr {
private:
    T* ptr_;

    // 计数指针，如果用对象，每次初始化之后都是新的值；如果用static，则不同的智能指针会拥有相同的count
    int* pCount_;

public:
    // 构造函数
    shared_ptr(T* p) : ptr_(p), pCount_(new int(1)) {
    }

    // 拷贝构造
    shared_ptr(shared_ptr& another) {
        ptr_ = another.ptr_;
        pCount = another.pCount_;
        ++(*pCount);
    }

    // 重载*操作符
    T& operator *() {
        return *ptr_;
    }

    // 重载->操作符
    T* operator ->() {
        return ptr_;
    }

    // 获取引用计数
    int getCount() {
        return *pCount_;
    }

    // 析构
    ~shared_ptr() {
        (*pCount_)--;
        if (0 == *pCount_) {
            delete ptr_;
            delete pCount_;
        }
    }
};
```

## 悬挂指针和野指针的区别
* 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，仍然指向已经被回收的内存地址
* 野指针：未初始化的指针被称为野指针

## 内存对齐
### 为什么需要内存对齐
1. 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。
2. 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。

### 内存对齐规则
1. 数据成员对齐规则：struct或者union的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员都按照#pragma pack数值和这个数据成员自身大小中更小的那个进行对齐。

2. 整体对齐规则：struct或者union的首地址按照内部最大数据成员的大小和#pragma pack数值较小的那个N进行对齐，并且结构体的总大小为N的整数倍，如有必要编译器也会在最后一个成员后面填充一些字节用于对齐。

## 指针类型区分
```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```
* int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量
* int(*p)[10]表示数组指针，强调的是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10
* int *p(int)是函数声明，函数名是p，参数是int类型，返回值是int*类型的
* int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值也是int类型

## c++有哪几种构造函数
* 默认构造函数
* 初始化构造函数
* 拷贝构造函数
* 移动构造函数
* 委托构造函数：把公共接口提取出来，然后不同的初始化列表
* 转换构造函数

## 判断大小端
* 大端：高字节存储在低地址中
* 小端：低字节存储在低地址中
在socket编程中，往往需要将操作系统所用的小端存储ip地址转换为大端存储，这样才能进行网络传输。

比如32bit的数字0x12345678

在小端模式的存储方式为：
内存地址 | 存放内容
---|---
0x4000 | 0x78 
0x4001 | 0x56
0x4002 | 0x34
0x4003 | 0x12

在大端模式的存储方式为：
内存地址 | 存放内容
---|---
0x4000 | 0x12
0x4001 | 0x34
0x4002 | 0x56
0x4003 | 0x78

如何在代码中进行判断？有如下两种方式：

* 方式一：使用强制类型转换
```
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
    cout << "big endian" << endl;
    else if(c == 0x34)
    cout << "little endian" << endl;
}
```
* 方式二：巧用union联合体
```
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
    cout << "big endian"<<endl;
    else if (value.ch == 0x34)
    cout << "little endian"<<endl;
}
```

## 成员初始化列表快在哪里？
少了一次调用构造函数的过程，列表初始化是发生在构造函数之前的。

## 四种强制转换
1. reinterpret_cast

reinterpret_cast<type-id> (expression)
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

2. const_cast

const_cast<type_id> (expression)

该运算符用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的。用法如下：

* 常量指针被转化成非常量的指针，并且仍然指向原来的对象
* 常量引用被转换成非常量的引用，并且仍然指向原来的对象
* const_cast一般用于修改底指针。如const char *p形式

3. static_cast

static_cast < type-id > (expression)

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
* 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
* 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
* 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
* 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
* 把空指针转换成目标类型的空指针
* 把任何类型的表达式转换成void类型

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。


4. dynamic_cast

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

## c++从代码到可执行程序经历了什么？
1. 预编译
2. 编译
3. 汇编
4. 链接（静态链接、动态链接）

## c++内存分区
C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。

## 迭代器++it和it++哪个好？
* 前置返回的是引用，后置返回的是对象
* 前置不会产生临时对象，后置会产生临时对象

前置更好

## CAS无锁编程
CAS(compare and swap)，引入CAS操作：该包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是CMPXCHG 汇编指令。有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。

## 简单实现vector
```
#include<iostream>
#include<cstring>

using namespace std;

template <typename T>
class Vector {
public:
    // 无参构造初始化
    Vector():T(nullptr), capacity_(0), size_(0){}
    
    // 有参构造初始化
    Vector(int size, T data) {
        capacity_ = 2*size;
        size_ = size;
        p = new T[capacity_];
        for(int i = 0; i < size_; i++) {
            this->p[i] = data;
        }
    }
    
    // 拷贝构造
    Vector(const Vector& v) {
        capacity_ = v.capacity_;
        size = v.size_;
        memcpy(p, v.p, size_*sizeof(T));
    }
    
    // 析构
    ~Vector() {
        if (nullptr != p) {
            delete[] p;
            p = nullptr;
        }
    }
    
    // 插入
    void push_back(T data) {
        if (size_ == capacity_) {
            T *new_p = new T[capacity_*2];
            memcpy(new_p, p, size_*sizeof(T));
            new_p->capacity *= 2;
            delete []p;
            p = nullptr;
            p = new_p;
        }
        
        p[size_] = data;
        size_++;
    }
    
    // 删除
    void pop_back() {
        if (size_ > 1) {
            size_--;
        }
    }
    
private:
    T *P;
    int capacity_;
    int size_;
};

```

## STL的两级空间配置器
1. 首先明白为什么需要二级空间配置器？

我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片，浪费了内存空间；每次都要进行调用malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。
关于STL中一级空间配置器和二级空间配置器的选择上，一般默认选择的为二级空间配置器。 如果大于128字节再转去一级配置器器。

* 一级配置器

一级空间配置器中重要的函数就是allocate、deallocate、reallocate。一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置。

* 二级配置器

二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统。

## hashtable解决冲突的办法
* 线性探测

使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位

* 开链

每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中

* 再散列

发生冲突时使用另一种hash函数再计算一个地址，直到不冲突

* 二次探测

使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测

* 公共溢出

一旦hash函数计算的结果相同，就放入公共溢出区








