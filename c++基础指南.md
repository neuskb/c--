# c++基础指南

## c和c++有什么区别
* c++是面向对象的语言，c是面向过程的语言
* c++引入new/delete运算符，取代了c中的malloc/free库函数
* c++引入引用的概念，c中没有
* c++引入类的概念，c中没有
* c++引入了函数重载的特性，c中没有

## a和&a有什么区别
假如int a[5]= {1,2,3,4,5};
* a是数组首元素地址，+1表示地址值加上一个int类型的大小，*(a+1)=a[1]
* &a是数组的指针，其类型为int(*)[10],表示整个数组的指针，这个指针指向的内存大小是整个数组的总大小，所以 *(&a+1)就是数组a尾元素后一个元素的地址

## static关键字的作用
* 修饰局部变量时，使得该变量在静态存储区分配内存，生命周期和程序相同，但是作用域还是局部作用域
* 修饰全局变量时，使得该变量在静态存储区分配内存，在声明该变量的整个文件中都是可见的，而在文件外是不可见的
* 修饰函数时，在声明该函数的整个文件中都是可见的
* 修饰成员变量时，所有的对象都只维护一份拷贝，可以实现不同对象间的数据共享，不需要实例化对象即可访问，不能在类内部初始化，一般在类外部初始化，并且初始化不加static
* 修饰成员函数时，该函数不接收this指针，只能访问类的静态成员，不需要实例化对象即可访问

## #define和const区别
* 编译器处理方式不同：#define宏是在预处理阶段展开，不能对宏定义进行调试，而const常量是在编译阶段使用
* 类型和安全检查不同，#define宏没有类型，不做任何检查，仅仅是代码展开，而const常量有具体类型，在编译阶段会执行类型检查
* 存储方式不同：#define宏仅仅是代码展开，直接进行替换，不会分配内存，而const常量会分配内存
* 定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效

## 静态链接和动态链接区别
* 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处，优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接
* 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接，优点在于多个程序可以共享同一个动态库，节省资源，缺点在于由于运行时加载，可能影响程序的前期执行性能

## float和0值比较
```
const float EPSINON = 0.00001;
//其中EPSINON是允许的误差（即精度）
if ((x >= - EPSINON) && (x <= EPSINON) {
    
} 
```
因为计算机在处理浮点数的时候是有误差的。

## sizeof和strlen的区别
* sizeof是一个操作符，strlen是库函数
* sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字段串作参数
* 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来
* 数组做sizeof的参数不退化，传递给strlen就退化成指针

## volatile有什么作用
易变关键字，告诉编译器不要对这个变量进行优化，每次都要去绝对地址取值，而不能从寄存器上取值，作用是用来进行多线程编程。

## 全局变量和局部变量，操作系统是怎么知道的
操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

## 简述strcpy、sprintf 与memcpy 的区别
* 操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
* 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
* 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字 符串的转化，memcpy 主要是内存块间的拷贝。

## 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？
应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。

优点：
* 在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；
* 相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；

缺点：

* 代码膨胀，产生更多的开销；
* 如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；
* 如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；
* 内联声明只是建议，是否内联由编译器决定，所以实际并不可控。

## shared_ptr是如何实现的？
* 构造函数中计数初始化为1；
* 拷贝构造函数中计数值加1；
* 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
* 析构函数中引用计数减1；
* 在赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象。
代码如下：
```
template <class T>
class shared_ptr {
private:
    T* ptr_;

    // 计数指针，如果用对象，每次初始化之后都是新的值；如果用static，则不同的智能指针会拥有相同的count
    int* pCount_;

public:
    // 构造函数
    shared_ptr(T* p) : ptr_(p), pCount_(new int(1)) {
    }

    // 拷贝构造
    shared_ptr(shared_ptr& another) {
        ptr_ = another.ptr_;
        pCount = another.pCount_;
        ++(*pCount);
    }

    // 重载*操作符
    T& operator *() {
        return *ptr_;
    }

    // 重载->操作符
    T* operator ->() {
        return ptr_;
    }

    // 获取引用计数
    int getCount() {
        return *pCount_;
    }

    // 析构
    ~shared_ptr() {
        (*pCount_)--;
        if (0 == *pCount_) {
            delete ptr_;
            delete pCount_;
        }
    }
};
```

## 悬挂指针和野指针的区别
* 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，仍然指向已经被回收的内存地址
* 野指针：未初始化的指针被称为野指针
