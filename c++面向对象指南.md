# c++面向对象指南
[toc]
## 面向对象的三大特征
* 封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。
* 继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；
* 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

## 动态绑定如何实现
当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放在虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表，当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，实现动态绑定。

## 虚函数表
虚函数表是针对类的，类的所有对象共享这个类的虚函数表，每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址不同，但是都指向同一虚函数表。

## 基类的构造函数能否定义为虚函数？
不能，虚函数的调用依赖虚函数表，而指向虚函数表的指针vptr需要在构造函数中初始化。

## 基类的析构函数需要定位为虚函数
为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，那派生类的析构就没有调用，造成内存泄漏。

## 如何将一个类不能实例化
* 将类定义为抽象类
* 将构造函数声明为private

## 强制类型转换运算符

* reinterpret_cast

改变指针或引用的类型、将指针或引用转换为一个足够长度的整型，将整型转换为指针或引用类型。

* const_cast

修改类型的const或者volatile属性

* static_cast

用于将一种数据类型强制转换为另一种数据类型。
1. 用于类层次结构中基类和派生类之间指针或引用转换，进行上行转换是安全的，进行下行转换是不安全的（没有动态类型检查）
2. 用于基本数据类型之间的转换
3. 把空指针转换成目标类型的空指针
4. 把任何类型的表达式转换为void类型

* dynamic_cast

运行时处理，进行类型检查。进行下行转换时，要比static_cast安全。

## 基类的虚函数表存放在什么区？虚表指针vptr的初始化时间
首先整理一下虚函数表的特征：
* 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
* 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
* 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)。

在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

## 构造函数、析构函数、虚函数可否声明为内联函数
首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。

register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。

构造函数和析构函数声明为内联函数是没有意义的。

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

将虚函数声明为inline，要分情况讨论：

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开。

综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。

## 什么是虚拟继承
c++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：
```
#include <iostream>
using namespace std;
class A{}
class B : virtual public A{};
class C : virtual public A{};
class D : public B, public C{};
int main()
{
    cout << "sizeof(A)：" << sizeof A <<endl; // 1，空对象，只有一个占位
    cout << "sizeof(B)：" << sizeof B <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(C)：" << sizeof C <<endl; // 4，一个bptr指针，省去占位,不需要对齐
    cout << "sizeof(D)：" << sizeof D <<endl; // 8，两个bptr，省去占位,不需要对齐
}
```
上述代码所体现的关系是，B和C虚拟继承A，D又公有继承B和C，这种方式是一种菱形继承或者钻石继承。

虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

## 模板和实现可不可以不放在一个文件？
不可以，编译期模板并不会生成二进制代码，所以找不到实现就会存在问题，一般模板的声明和实现都是放在头文件中。

## 虚函数的代价
* 每个类都会产生一个虚函数表
* 每个类对象都会有一个指向虚函数表的vptr



