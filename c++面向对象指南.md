# c++面向对象指南

## 面向对象的三大特征
* 封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。
* 继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；
* 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

## 动态绑定如何实现
当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放在虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表，当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，实现动态绑定。

## 虚函数表
虚函数表是针对类的，类的所有对象共享这个类的虚函数表，每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址不同，但是都指向同一虚函数表。

## 基类的构造函数能否定义为虚函数？
不能，虚函数的调用依赖虚函数表，而指向虚函数表的指针vptr需要在构造函数中初始化。

## 基类的析构函数需要定位为虚函数
为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，那派生类的析构就没有调用，造成内存泄漏。

## 如何将一个类不能实例化
* 将类定义为抽象类
* 将构造函数声明为private

## 强制类型转换运算符

* reinterpret_cast

改变指针或引用的类型、将指针或引用转换为一个足够长度的整型，将整型转换为指针或引用类型。

* const_cast

修改类型的const或者volatile属性

* static_cast

用于将一种数据类型强制转换为另一种数据类型。
1. 用于类层次结构中基类和派生类之间指针或引用转换，进行上行转换是安全的，进行下行转换是不安全的（没有动态类型检查）
2. 用于基本数据类型之间的转换
3. 把空指针转换成目标类型的空指针
4. 把任何类型的表达式转换为void类型

* dynamic_cast

运行时处理，进行类型检查。进行下行转换时，要比static_cast安全。


